<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCBE Swarm Battle Trainer</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
        }
        #ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #00ff88;
            border-radius: 8px;
            max-width: 280px;
        }
        h1 { font-size: 14px; margin-bottom: 10px; color: #00ffcc; }
        .stat { font-size: 11px; margin: 4px 0; }
        .stat-value { color: #ffcc00; }
        button {
            background: #1a1a2e;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 8px 12px;
            margin: 4px 2px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
        }
        button:hover { background: #00ff88; color: #0a0a0f; }
        button.active { background: #00ff88; color: #0a0a0f; }
        #controls { margin-top: 10px; }
        #generation-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #ff6600;
            border-radius: 8px;
            z-index: 100;
        }
        #neural-viz {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #6600ff;
            border-radius: 8px;
            z-index: 100;
            width: 300px;
        }
        .brain-canvas {
            width: 100%;
            height: 80px;
            background: #0a0a1a;
            border: 1px solid #333;
            margin-top: 8px;
        }
        #log {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 100;
            width: 250px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 10px;
        }
        .log-entry { margin: 2px 0; opacity: 0.8; }
        .log-good { color: #00ff88; }
        .log-bad { color: #ff4444; }
        .log-info { color: #88ccff; }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>SCBE SWARM BATTLE TRAINER</h1>
        <div class="stat">Generation: <span class="stat-value" id="gen">1</span></div>
        <div class="stat">Best Fitness: <span class="stat-value" id="best-fitness">0</span></div>
        <div class="stat">Avg Fitness: <span class="stat-value" id="avg-fitness">0</span></div>
        <div class="stat">Battles: <span class="stat-value" id="battles">0</span></div>
        <div class="stat">Win Rate: <span class="stat-value" id="winrate">0%</span></div>
        <div id="controls">
            <button id="btn-start">START TRAINING</button>
            <button id="btn-pause">PAUSE</button>
            <button id="btn-fast">FAST MODE</button>
            <br>
            <button id="btn-hex">HEX</button>
            <button id="btn-tetra">TETRA</button>
            <button id="btn-scatter">SCATTER</button>
        </div>
    </div>

    <div id="generation-info">
        <h1 style="color: #ff6600;">SACRED TONGUE SQUAD</h1>
        <div class="stat">KO (Flow): <span class="stat-value" id="ko-stat">100%</span></div>
        <div class="stat">AV (Diplo): <span class="stat-value" id="av-stat">100%</span></div>
        <div class="stat">RU (Tank): <span class="stat-value" id="ru-stat">100%</span></div>
        <div class="stat">CA (DPS): <span class="stat-value" id="ca-stat">100%</span></div>
        <div class="stat">UM (Stealth): <span class="stat-value" id="um-stat">100%</span></div>
        <div class="stat">DR (Architect): <span class="stat-value" id="dr-stat">100%</span></div>
    </div>

    <div id="neural-viz">
        <h1 style="color: #6600ff;">NEURAL WEIGHTS</h1>
        <canvas class="brain-canvas" id="brain-canvas"></canvas>
        <div class="stat" style="margin-top: 8px;">Mutation Rate: <span class="stat-value" id="mutation">5%</span></div>
    </div>

    <div id="phdm-panel" style="position: fixed; top: 180px; right: 10px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #ff00ff; border-radius: 8px; z-index: 100; width: 200px;">
        <h1 style="color: #ff00ff; font-size: 14px;">PHDM SKULL STATE</h1>
        <div class="stat">Active Lobe: <span class="stat-value" id="active-lobe">CUBE</span></div>
        <div class="stat">Flux (ν): <span class="stat-value" id="flux-value">1.618</span></div>
        <div class="stat">Breathing: <span class="stat-value" id="breath-state">POLLY</span></div>
        <div class="stat">Hamiltonian: <span class="stat-value" id="hamilton-valid">✓ VALID</span></div>
        <canvas id="skull-canvas" style="width: 100%; height: 60px; background: #0a0a1a; border: 1px solid #333; margin-top: 8px;"></canvas>
    </div>

    <div id="gravity-panel" style="position: fixed; top: 380px; right: 10px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00ffff; border-radius: 8px; z-index: 100; width: 200px;">
        <h1 style="color: #00ffff; font-size: 14px;">GRAVITATIONAL BRAKE</h1>
        <div class="stat">Frozen Agents: <span class="stat-value" id="frozen-count">0</span></div>
        <div class="stat">Avg Dilation: <span class="stat-value" id="avg-dilation">100%</span></div>
        <div class="stat">Event Horizons: <span class="stat-value" id="event-horizons">0</span></div>
    </div>

    <div id="log">
        <div class="log-entry log-info">System initialized...</div>
    </div>

    <div id="game-container"></div>

    <script>
// ============================================
// SCBE SWARM BATTLE TRAINER
// Military-style AI training with genetic algorithms
// Integrated with AetherBrain PHDM + Gravitational Braking
// ============================================

// ============================================
// PHDM - POLYHEDRAL HAMILTONIAN DYNAMIC MESH
// The "Crystal Skull" cognitive architecture
// ============================================

const POLYHEDRA = {
    // Core Ring (r < 0.3) - Platonic Solids - Super-Ego/Safety
    TETRAHEDRON: { id: 'TETRA', ring: 'CORE', faces: 4, weight: 1.0, role: 'axiom' },
    CUBE: { id: 'CUBE', ring: 'CORE', faces: 6, weight: 1.2, role: 'structure' },
    OCTAHEDRON: { id: 'OCTA', ring: 'CORE', faces: 8, weight: 1.5, role: 'balance' },
    DODECAHEDRON: { id: 'DODECA', ring: 'CORE', faces: 12, weight: 2.0, role: 'harmony' },
    ICOSAHEDRON: { id: 'ICOSA', ring: 'CORE', faces: 20, weight: 2.5, role: 'flow' },

    // Inner Ring - Archimedean Solids - Cortex/Logic
    TRUNCATED_TETRA: { id: 'TTETRA', ring: 'INNER', faces: 8, weight: 3.0, role: 'reason' },
    CUBOCTAHEDRON: { id: 'CUBOCTA', ring: 'INNER', faces: 14, weight: 3.5, role: 'synthesis' },
    TRUNCATED_CUBE: { id: 'TCUBE', ring: 'INNER', faces: 14, weight: 4.0, role: 'planning' },

    // Middle Ring - Toroidal - Cerebellum/Loop
    SZILASSI: { id: 'SZIL', ring: 'MIDDLE', faces: 7, weight: 5.0, role: 'recursion', holes: 1 },
    CSASZAR: { id: 'CSASZAR', ring: 'MIDDLE', faces: 7, weight: 5.5, role: 'diagnostics', holes: 1 },

    // Edge Ring - Kepler-Poinsot - Id/Risk (DANGER ZONE)
    SMALL_STELLATED: { id: 'SSTELL', ring: 'EDGE', faces: 12, weight: 8.0, role: 'creativity', spiky: true },
    GREAT_STELLATED: { id: 'GSTELL', ring: 'EDGE', faces: 12, weight: 10.0, role: 'hallucination', spiky: true }
};

// Hamiltonian adjacency - valid paths through the skull
const HAMILTONIAN_EDGES = {
    'TETRA': ['CUBE', 'OCTA'],
    'CUBE': ['TETRA', 'OCTA', 'TTETRA'],
    'OCTA': ['CUBE', 'DODECA', 'CUBOCTA'],
    'DODECA': ['OCTA', 'ICOSA', 'TCUBE'],
    'ICOSA': ['DODECA', 'TTETRA'],
    'TTETRA': ['CUBE', 'ICOSA', 'SZIL'],
    'CUBOCTA': ['OCTA', 'TCUBE', 'CSASZAR'],
    'TCUBE': ['DODECA', 'CUBOCTA', 'SZIL'],
    'SZIL': ['TTETRA', 'TCUBE', 'SSTELL'],
    'CSASZAR': ['CUBOCTA', 'SSTELL'],
    'SSTELL': ['SZIL', 'CSASZAR', 'GSTELL'],
    'GSTELL': ['SSTELL'] // Dead end - hallucination trap
};

// Dimensional breathing states
const BREATH_STATES = {
    POLLY: { nu: 1.618, radius: 1.0, name: 'Normal' },
    QUASI: { nu: 2.414, radius: 0.8, name: 'Cautious' },
    DEMI: { nu: 0.618, radius: 1.2, name: 'Alert' }
};

// PHDM Brain for strategic decisions
class PHDMBrain {
    constructor() {
        this.currentLobe = POLYHEDRA.CUBE;
        this.thoughtPath = ['CUBE'];
        this.flux = BREATH_STATES.POLLY.nu;
        this.breathState = 'POLLY';
        this.pathValid = true;
    }

    // Transition to a new cognitive lobe
    transitionTo(lobeId) {
        const current = this.currentLobe.id;
        const validNexts = HAMILTONIAN_EDGES[current] || [];

        if (validNexts.includes(lobeId)) {
            // Valid Hamiltonian step
            this.currentLobe = Object.values(POLYHEDRA).find(p => p.id === lobeId);
            this.thoughtPath.push(lobeId);
            this.pathValid = true;

            // Detect loops (max path length)
            if (this.thoughtPath.length > 12) {
                this.thoughtPath = this.thoughtPath.slice(-6);
            }
            return true;
        } else {
            // Invalid path - phason shift!
            this.pathValid = false;
            return false;
        }
    }

    // Get lobe for a given intent
    selectLobeForIntent(intent) {
        switch (intent) {
            case 'attack': return 'ICOSA'; // Flow for aggression
            case 'defend': return 'CUBE';  // Structure for defense
            case 'retreat': return 'TETRA'; // Axiom - survival first
            case 'flank': return 'TTETRA'; // Reason for tactics
            case 'diagnose': return 'CSASZAR'; // Self-check
            case 'creative': return 'SSTELL'; // Risk for creativity
            default: return 'OCTA'; // Balance
        }
    }

    // Compute energy cost (Harmonic Wall)
    computeEnergyCost(divergence) {
        const R = 2.62; // Runethic weight
        // H(d) = R^(d²) - super-exponential
        return Math.pow(R, divergence * divergence);
    }

    // Update breathing based on threat level
    updateBreathing(threatLevel) {
        if (threatLevel > 0.7) {
            this.breathState = 'QUASI';
            this.flux = BREATH_STATES.QUASI.nu;
        } else if (threatLevel > 0.4) {
            this.breathState = 'DEMI';
            this.flux = BREATH_STATES.DEMI.nu;
        } else {
            this.breathState = 'POLLY';
            this.flux = BREATH_STATES.POLLY.nu;
        }
    }

    // Get cognitive modifier for neural outputs
    getCognitiveModifier() {
        // Spiky thoughts (Kepler-Poinsot) add variance
        if (this.currentLobe.spiky) {
            return {
                variance: 0.3,
                aggression: 1.5,
                risk: true
            };
        }
        // Core thoughts are stable
        if (this.currentLobe.ring === 'CORE') {
            return {
                variance: 0.05,
                aggression: 0.8,
                risk: false
            };
        }
        // Default
        return {
            variance: 0.1,
            aggression: 1.0,
            risk: false
        };
    }
}

// ============================================
// GRAVITATIONAL BRAKING SYSTEM
// Time dilation for rogue agents
// t_G = t * sqrt(1 - (k*d)/(r+ε))
// ============================================

class GravitationalBrake {
    constructor() {
        this.couplingConstant = 1.0; // k
        this.trustRadius = 0.3;       // r (core ring)
        this.epsilon = 0.001;         // ε
        this.maxDivergence = 1.0;
        this.minDilation = 0.01;
        this.frozenAgents = new Map();
    }

    // Compute time dilation factor (0 = frozen, 1 = normal)
    computeDilationFactor(divergence) {
        const k = this.couplingConstant;
        const r = this.trustRadius;
        const eps = this.epsilon;

        // Clamp divergence
        const d = Math.max(0, Math.min(divergence, this.maxDivergence));

        // t_G = t * sqrt(1 - (k*d)/(r+ε))
        const term = 1 - (k * d) / (r + eps);

        if (term <= 0) {
            return 0; // Event horizon - completely frozen
        }

        return Math.sqrt(term);
    }

    // Apply braking to an agent
    applyBraking(agentId, normalizedDistance) {
        const dilation = this.computeDilationFactor(normalizedDistance);
        const inEventHorizon = dilation < this.minDilation;

        if (inEventHorizon) {
            this.frozenAgents.set(agentId, true);
        } else {
            this.frozenAgents.delete(agentId);
        }

        let action, severity;
        if (inEventHorizon) {
            action = 'QUARANTINE';
            severity = 1.0;
        } else if (dilation < 0.1) {
            action = 'FREEZE';
            severity = 0.9;
        } else if (dilation < 0.3) {
            action = 'BRAKE';
            severity = 0.7;
        } else if (dilation < 0.6) {
            action = 'SLOW';
            severity = 0.4;
        } else {
            action = 'CONTINUE';
            severity = 0.0;
        }

        return { dilation, inEventHorizon, action, severity };
    }

    // Dilate velocity (agents near event horizon move slower)
    dilateVelocity(vx, vy, dilation) {
        return { x: vx * dilation, y: vy * dilation };
    }

    // Get frozen agent count
    getFrozenCount() {
        return this.frozenAgents.size;
    }
}

// Global PHDM and brake instances
let globalPHDM = new PHDMBrain();
let globalBrake = new GravitationalBrake();

// Sacred Tongues with synaptic weights and phase angles
// These define the "wiring" between cognitive lobes
const SACRED_TONGUES = [
    { id: 'KO', name: 'Koraelin', color: 0x00ffcc, role: 'Flow', speed: 1.5, damage: 0.8, hp: 80,
      phase: 0, weight: 1.00, neurotransmitter: 'dopamine', friction: 0.1 },
    { id: 'AV', name: 'Avali', color: 0xffcc00, role: 'Diplomat', speed: 1.0, damage: 0.6, hp: 100,
      phase: 60, weight: 1.90, neurotransmitter: 'context', friction: 0.3 },
    { id: 'RU', name: 'Runethic', color: 0x8b4513, role: 'Tank', speed: 0.7, damage: 1.0, hp: 150,
      phase: 120, weight: 2.62, neurotransmitter: 'serotonin', friction: 0.7 },
    { id: 'CA', name: 'Cassisivadan', color: 0xff0066, role: 'DPS', speed: 1.2, damage: 1.5, hp: 60,
      phase: 180, weight: 4.24, neurotransmitter: 'adrenaline', friction: 0.2 },
    { id: 'UM', name: 'Umbroth', color: 0x6600cc, role: 'Stealth', speed: 1.3, damage: 1.2, hp: 70,
      phase: 240, weight: 6.85, neurotransmitter: 'gaba', friction: 0.5 },
    { id: 'DR', name: 'Draumric', color: 0x4444ff, role: 'Architect', speed: 0.8, damage: 0.9, hp: 120,
      phase: 300, weight: 11.09, neurotransmitter: 'cortisol', friction: 0.9 }
];

// Neural network for each agent with Sacred Tongue synaptic integration
class NeuralBrain {
    constructor(inputSize = 10, hiddenSize = 6, outputSize = 4) {
        // Extended inputs: [nearestEnemyDist, nearestEnemyAngle, health, nearestAllyDist,
        //                   formationBonus, enemyCount, allyCount, random, phdmModifier, gravityDilation]
        // Outputs: [moveX, moveY, attack, retreat]
        this.weightsIH = this.randomMatrix(inputSize, hiddenSize);
        this.weightsHO = this.randomMatrix(hiddenSize, outputSize);
        this.fitness = 0;
        this.tongueIndex = 0; // Will be set when assigned to agent
        this.phdm = new PHDMBrain(); // Each agent has its own cognitive state
    }

    randomMatrix(rows, cols) {
        const m = [];
        for (let i = 0; i < rows; i++) {
            m[i] = [];
            for (let j = 0; j < cols; j++) {
                m[i][j] = (Math.random() * 2 - 1);
            }
        }
        return m;
    }

    // Apply Sacred Tongue synaptic weights to hidden layer
    applySynapticWeights(hidden) {
        const tongue = SACRED_TONGUES[this.tongueIndex] || SACRED_TONGUES[0];
        const modulated = [];

        for (let j = 0; j < hidden.length; j++) {
            // Each hidden neuron is influenced by the tongue's weight
            // Normalized by max weight (11.09 = DR)
            const synapticGain = tongue.weight / 11.09;
            // Friction reduces signal (heavier tongues = more damping)
            const dampening = 1 - (tongue.friction * 0.3);
            modulated[j] = hidden[j] * synapticGain * dampening;
        }

        return modulated;
    }

    forward(inputs, cognitiveModifier = null) {
        // Hidden layer
        let hidden = [];
        for (let j = 0; j < this.weightsIH[0].length; j++) {
            let sum = 0;
            for (let i = 0; i < inputs.length; i++) {
                sum += inputs[i] * this.weightsIH[i][j];
            }
            hidden[j] = Math.tanh(sum);
        }

        // Apply Sacred Tongue synaptic modulation
        hidden = this.applySynapticWeights(hidden);

        // Apply PHDM cognitive modifier if provided
        if (cognitiveModifier) {
            hidden = hidden.map(h => {
                const variance = (Math.random() - 0.5) * 2 * cognitiveModifier.variance;
                return h + variance;
            });
        }

        // Output layer
        const outputs = [];
        for (let j = 0; j < this.weightsHO[0].length; j++) {
            let sum = 0;
            for (let i = 0; i < hidden.length; i++) {
                sum += hidden[i] * this.weightsHO[i][j];
            }
            outputs[j] = Math.tanh(sum);
        }

        // Modify outputs based on cognitive state
        if (cognitiveModifier && cognitiveModifier.aggression !== 1.0) {
            outputs[2] *= cognitiveModifier.aggression; // Attack modifier
        }

        return outputs;
    }

    mutate(rate = 0.05) {
        for (let i = 0; i < this.weightsIH.length; i++) {
            for (let j = 0; j < this.weightsIH[i].length; j++) {
                if (Math.random() < rate) {
                    this.weightsIH[i][j] += (Math.random() * 0.4 - 0.2);
                }
            }
        }
        for (let i = 0; i < this.weightsHO.length; i++) {
            for (let j = 0; j < this.weightsHO[i].length; j++) {
                if (Math.random() < rate) {
                    this.weightsHO[i][j] += (Math.random() * 0.4 - 0.2);
                }
            }
        }
    }

    clone() {
        const baby = new NeuralBrain();
        baby.weightsIH = JSON.parse(JSON.stringify(this.weightsIH));
        baby.weightsHO = JSON.parse(JSON.stringify(this.weightsHO));
        baby.tongueIndex = this.tongueIndex;
        return baby;
    }

    crossover(partner) {
        const child = new NeuralBrain();
        for (let i = 0; i < this.weightsIH.length; i++) {
            for (let j = 0; j < this.weightsIH[i].length; j++) {
                child.weightsIH[i][j] = Math.random() < 0.5 ? this.weightsIH[i][j] : partner.weightsIH[i][j];
            }
        }
        for (let i = 0; i < this.weightsHO.length; i++) {
            for (let j = 0; j < this.weightsHO[i].length; j++) {
                child.weightsHO[i][j] = Math.random() < 0.5 ? this.weightsHO[i][j] : partner.weightsHO[i][j];
            }
        }
        return child;
    }

    // Get the current intent based on outputs
    getIntent(outputs) {
        const [moveX, moveY, attack, retreat] = outputs;
        if (retreat > 0.5) return 'retreat';
        if (attack > 0.5) return 'attack';
        if (Math.abs(moveX) > 0.5 || Math.abs(moveY) > 0.5) return 'flank';
        return 'defend';
    }

    // Update PHDM state based on decision
    updateCognitiveState(intent) {
        const targetLobe = this.phdm.selectLobeForIntent(intent);
        return this.phdm.transitionTo(targetLobe);
    }
}

// Genetic Algorithm Manager
class GeneticTrainer {
    constructor(populationSize = 6) {
        this.populationSize = populationSize;
        this.generation = 1;
        this.population = [];
        this.bestFitness = 0;
        this.bestBrain = null;
        this.battles = 0;
        this.wins = 0;
        this.mutationRate = 0.05;

        // Initialize population
        for (let i = 0; i < populationSize; i++) {
            this.population.push(new NeuralBrain());
        }
    }

    evolve() {
        // Sort by fitness
        this.population.sort((a, b) => b.fitness - a.fitness);

        // Track best
        if (this.population[0].fitness > this.bestFitness) {
            this.bestFitness = this.population[0].fitness;
            this.bestBrain = this.population[0].clone();
        }

        // Create next generation
        const newPop = [];

        // Elitism: keep top 2
        newPop.push(this.population[0].clone());
        newPop.push(this.population[1].clone());

        // Crossover and mutate for the rest
        while (newPop.length < this.populationSize) {
            const parent1 = this.select();
            const parent2 = this.select();
            const child = parent1.crossover(parent2);
            child.mutate(this.mutationRate);
            newPop.push(child);
        }

        this.population = newPop;
        this.generation++;

        // Reset fitness for new generation
        this.population.forEach(b => b.fitness = 0);
    }

    select() {
        // Tournament selection
        const tournament = [];
        for (let i = 0; i < 3; i++) {
            tournament.push(this.population[Math.floor(Math.random() * this.population.length)]);
        }
        tournament.sort((a, b) => b.fitness - a.fitness);
        return tournament[0];
    }

    recordBattle(won, scores) {
        this.battles++;
        if (won) this.wins++;

        // Update individual fitness
        scores.forEach((score, i) => {
            if (this.population[i]) {
                this.population[i].fitness += score;
            }
        });
    }
}

// Game Configuration
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game-container',
    backgroundColor: '#0a0a0f',
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

let game;
let trainer;
let allies = [];
let enemies = [];
let projectiles = [];
let battleActive = false;
let paused = false;
let fastMode = false;
let currentFormation = 'hex';
let arenaRadius;
let centerX, centerY;
let battleTimer = 0;
const BATTLE_DURATION = 30000; // 30 seconds per battle

function preload() {
    // Generate textures programmatically
}

function create() {
    const scene = this;
    centerX = config.width / 2;
    centerY = config.height / 2;
    arenaRadius = Math.min(centerX, centerY) - 100;

    trainer = new GeneticTrainer(6);

    // Draw Poincare ball arena
    drawArena(scene);

    // Setup controls
    setupControls(scene);

    // Start first battle
    startBattle(scene);
}

function drawArena(scene) {
    const graphics = scene.add.graphics();

    // Poincare ball boundary
    graphics.lineStyle(2, 0x00ff88, 0.5);
    graphics.strokeCircle(centerX, centerY, arenaRadius);

    // Inner rings (trust zones)
    graphics.lineStyle(1, 0x00ff88, 0.2);
    graphics.strokeCircle(centerX, centerY, arenaRadius * 0.3); // Core
    graphics.strokeCircle(centerX, centerY, arenaRadius * 0.6); // Inner
    graphics.strokeCircle(centerX, centerY, arenaRadius * 0.85); // Outer

    // Grid lines
    graphics.lineStyle(1, 0x00ff88, 0.1);
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        graphics.lineBetween(
            centerX, centerY,
            centerX + Math.cos(angle) * arenaRadius,
            centerY + Math.sin(angle) * arenaRadius
        );
    }

    // Labels
    scene.add.text(centerX, centerY - arenaRadius - 20, 'POINCARE BATTLE ARENA', {
        fontSize: '16px', fill: '#00ff88', fontFamily: 'Courier New'
    }).setOrigin(0.5);

    scene.add.text(centerX, centerY, 'CORE', {
        fontSize: '10px', fill: '#00ff88', fontFamily: 'Courier New', alpha: 0.3
    }).setOrigin(0.5);
}

let agentIdCounter = 0;

function createAgent(scene, tongueIndex, x, y, isEnemy = false) {
    const tongue = SACRED_TONGUES[tongueIndex];
    const color = isEnemy ? 0xff4444 : tongue.color;

    const agent = scene.add.circle(x, y, isEnemy ? 12 : 15, color);
    scene.physics.add.existing(agent);

    agent.id = 'agent_' + (++agentIdCounter); // Unique ID for gravitational tracking
    agent.tongue = tongue;
    agent.tongueIndex = tongueIndex;
    agent.isEnemy = isEnemy;
    agent.hp = tongue.hp;
    agent.maxHp = tongue.hp;
    agent.speed = tongue.speed * 100;
    agent.damage = tongue.damage * 10;
    agent.attackCooldown = 0;
    agent.score = 0;
    agent.dilationFactor = 1.0; // Gravitational time dilation

    // Health bar
    agent.hpBar = scene.add.rectangle(x, y - 20, 24, 4, 0x00ff00);
    agent.hpBarBg = scene.add.rectangle(x, y - 20, 24, 4, 0x333333);
    agent.hpBarBg.setDepth(0);
    agent.hpBar.setDepth(1);

    // Label
    agent.label = scene.add.text(x, y + 20, isEnemy ? 'E' : tongue.id, {
        fontSize: '10px', fill: isEnemy ? '#ff4444' : '#ffffff', fontFamily: 'Courier New'
    }).setOrigin(0.5);

    return agent;
}

function startBattle(scene) {
    // Clear previous
    allies.forEach(a => { a.destroy(); a.hpBar.destroy(); a.hpBarBg.destroy(); a.label.destroy(); });
    enemies.forEach(e => { e.destroy(); e.hpBar.destroy(); e.hpBarBg.destroy(); e.label.destroy(); });
    projectiles.forEach(p => p.destroy());
    allies = [];
    enemies = [];
    projectiles = [];

    // Spawn allies in formation with PHDM-enabled brains
    const allyPositions = getFormationPositions(currentFormation, 6, arenaRadius * 0.3);
    for (let i = 0; i < 6; i++) {
        const pos = allyPositions[i];
        const agent = createAgent(scene, i, centerX + pos.x, centerY + pos.y, false);
        agent.brain = trainer.population[i];
        agent.brain.tongueIndex = i; // Assign Sacred Tongue identity
        allies.push(agent);
    }

    // Reset gravitational brake state
    globalBrake.frozenAgents.clear();

    // Spawn enemies in random positions (outer ring)
    const enemyCount = 4 + Math.floor(trainer.generation / 5); // More enemies as generations progress
    for (let i = 0; i < Math.min(enemyCount, 10); i++) {
        const angle = (i / enemyCount) * Math.PI * 2 + Math.random() * 0.5;
        const dist = arenaRadius * (0.6 + Math.random() * 0.3);
        const agent = createAgent(scene, i % 6, centerX + Math.cos(angle) * dist, centerY + Math.sin(angle) * dist, true);
        enemies.push(agent);
    }

    battleActive = true;
    battleTimer = 0;
    addLog('Battle started! Gen ' + trainer.generation, 'info');
}

function getFormationPositions(type, count, radius) {
    const positions = [];

    if (type === 'hex') {
        for (let i = 0; i < count; i++) {
            const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
            positions.push({
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius
            });
        }
    } else if (type === 'tetra') {
        // Tetrahedral projection
        const layers = [[0], [1, 2, 3], [4, 5]];
        let idx = 0;
        layers.forEach((layer, li) => {
            const r = radius * (0.3 + li * 0.35);
            layer.forEach((_, i) => {
                const angle = (i / layer.length) * Math.PI * 2 + li * 0.5;
                if (idx < count) {
                    positions.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
                    idx++;
                }
            });
        });
    } else if (type === 'scatter') {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * radius;
            positions.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
        }
    }

    while (positions.length < count) {
        positions.push({ x: 0, y: 0 });
    }
    return positions;
}

function update(time, delta) {
    if (paused || !battleActive) return;

    const dt = fastMode ? delta * 3 : delta;
    battleTimer += dt;

    const scene = this;

    // Calculate global threat level for PHDM breathing
    const aliveEnemiesCount = enemies.filter(e => e.hp > 0).length;
    const aliveAlliesCount = allies.filter(a => a.hp > 0).length;
    const threatLevel = aliveEnemiesCount / Math.max(1, aliveAlliesCount + aliveEnemiesCount);
    globalPHDM.updateBreathing(threatLevel);

    // Update allies (AI controlled with PHDM integration)
    allies.forEach((ally, idx) => {
        if (ally.hp <= 0) return;

        // Calculate inputs for neural network (extended with PHDM + gravity)
        const inputs = calculateInputs(ally, allies, enemies);

        // Get cognitive modifier from PHDM
        const cognitiveModifier = ally.brain.phdm.getCognitiveModifier();

        // Forward pass with cognitive modulation
        const outputs = ally.brain.forward(inputs, cognitiveModifier);

        // Determine intent and update Hamiltonian path
        const intent = ally.brain.getIntent(outputs);
        const validPath = ally.brain.updateCognitiveState(intent);

        // If path invalid (phason shift), reduce effectiveness
        const pathPenalty = validPath ? 1.0 : 0.5;

        // Apply outputs with path penalty
        const moveX = outputs[0] * ally.speed * (dt / 1000) * pathPenalty;
        const moveY = outputs[1] * ally.speed * (dt / 1000) * pathPenalty;
        const shouldAttack = outputs[2] > 0.3;
        const shouldRetreat = outputs[3] > 0.5;

        // Movement
        let newX = ally.x + moveX;
        let newY = ally.y + moveY;

        // Retreat behavior
        if (shouldRetreat && ally.hp < ally.maxHp * 0.3) {
            const toCenterX = centerX - ally.x;
            const toCenterY = centerY - ally.y;
            const dist = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
            if (dist > 0) {
                newX = ally.x + (toCenterX / dist) * ally.speed * (dt / 1000);
                newY = ally.y + (toCenterY / dist) * ally.speed * (dt / 1000);
            }
        }

        // Keep in arena
        const distFromCenter = Math.sqrt((newX - centerX) ** 2 + (newY - centerY) ** 2);
        if (distFromCenter < arenaRadius - 20) {
            ally.x = newX;
            ally.y = newY;
        }

        // Attack (cooldown dilated by PHDM flux)
        ally.attackCooldown -= dt;
        if (shouldAttack && ally.attackCooldown <= 0) {
            const target = findNearestEnemy(ally, enemies);
            if (target && target.hp > 0) {
                const dist = Phaser.Math.Distance.Between(ally.x, ally.y, target.x, target.y);
                if (dist < 150) {
                    attack(scene, ally, target);
                    // Cooldown modified by PHDM flux (golden ratio timing)
                    ally.attackCooldown = 500 / ally.brain.phdm.flux;
                }
            }
        }

        // Update visuals
        updateAgentVisuals(ally);

        // Fitness rewards
        ally.score += dt * 0.001; // Survival bonus
        if (ally.hp > ally.maxHp * 0.5) ally.score += dt * 0.0005; // Health bonus
        if (validPath) ally.score += dt * 0.0002; // Hamiltonian path bonus
    });

    // Track gravity metrics
    let totalDilation = 0;
    let eventHorizonCount = 0;

    // Update enemies (with GRAVITATIONAL BRAKING)
    enemies.forEach(enemy => {
        if (enemy.hp <= 0) return;

        // Calculate normalized distance from center (divergence)
        const distFromCenter = Math.sqrt((enemy.x - centerX) ** 2 + (enemy.y - centerY) ** 2);
        const normalizedDist = distFromCenter / arenaRadius;

        // Apply gravitational braking!
        // Enemies approaching the core get time-dilated
        // Invert the divergence - closer to center = more braking for ENEMIES
        const invertedDivergence = 1 - normalizedDist;
        const brakeResult = globalBrake.applyBraking(enemy.id, invertedDivergence * 0.5);

        // Store dilation on enemy for visualization
        enemy.dilationFactor = brakeResult.dilation;
        totalDilation += brakeResult.dilation;

        if (brakeResult.inEventHorizon) {
            eventHorizonCount++;
            // Frozen enemy - can't act!
            enemy.alpha = 0.3;
            updateAgentVisuals(enemy);
            return;
        }

        // Find nearest ally and move toward (speed dilated!)
        const target = findNearestEnemy(enemy, allies);
        if (target && target.hp > 0) {
            const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, target.x, target.y);
            const dilatedSpeed = enemy.speed * 0.5 * brakeResult.dilation;
            enemy.x += Math.cos(angle) * dilatedSpeed * (dt / 1000);
            enemy.y += Math.sin(angle) * dilatedSpeed * (dt / 1000);

            // Attack (cooldown dilated!)
            enemy.attackCooldown -= dt * brakeResult.dilation;
            const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, target.x, target.y);
            if (dist < 100 && enemy.attackCooldown <= 0) {
                attack(scene, enemy, target);
                enemy.attackCooldown = 700 / brakeResult.dilation; // Longer cooldown when slowed
            }
        }

        // Visual feedback - alpha based on dilation
        enemy.alpha = 0.5 + (brakeResult.dilation * 0.5);
        updateAgentVisuals(enemy);
    });

    // Update gravity panel
    const aliveEnemies = enemies.filter(e => e.hp > 0);
    document.getElementById('frozen-count').textContent = globalBrake.getFrozenCount();
    document.getElementById('avg-dilation').textContent =
        aliveEnemies.length > 0 ? ((totalDilation / aliveEnemies.length) * 100).toFixed(1) + '%' : 'N/A';
    document.getElementById('event-horizons').textContent = eventHorizonCount;

    // Update projectiles
    projectiles = projectiles.filter(p => {
        if (!p.active) return false;
        p.life -= dt;
        if (p.life <= 0) {
            p.destroy();
            return false;
        }
        return true;
    });

    // Check battle end
    const aliveAllies = allies.filter(a => a.hp > 0).length;
    const aliveEnemies = enemies.filter(e => e.hp > 0).length;

    if (aliveAllies === 0 || aliveEnemies === 0 || battleTimer > BATTLE_DURATION) {
        endBattle(scene, aliveAllies > 0 && aliveEnemies === 0);
    }

    // Update UI
    updateUI();
}

function calculateInputs(agent, allies, enemies) {
    // Find nearest enemy
    let nearestEnemy = null;
    let nearestEnemyDist = 9999;
    enemies.forEach(e => {
        if (e.hp <= 0) return;
        const d = Phaser.Math.Distance.Between(agent.x, agent.y, e.x, e.y);
        if (d < nearestEnemyDist) {
            nearestEnemyDist = d;
            nearestEnemy = e;
        }
    });

    // Find nearest ally
    let nearestAllyDist = 9999;
    allies.forEach(a => {
        if (a === agent || a.hp <= 0) return;
        const d = Phaser.Math.Distance.Between(agent.x, agent.y, a.x, a.y);
        if (d < nearestAllyDist) nearestAllyDist = d;
    });

    // Calculate formation bonus (how close to ideal position)
    const distFromCenter = Phaser.Math.Distance.Between(agent.x, agent.y, centerX, centerY);
    const formationBonus = 1 - (distFromCenter / arenaRadius);

    // Count nearby
    const enemyCount = enemies.filter(e => e.hp > 0).length / 10;
    const allyCount = allies.filter(a => a.hp > 0).length / 6;

    // Angle to nearest enemy
    let enemyAngle = 0;
    if (nearestEnemy) {
        enemyAngle = Phaser.Math.Angle.Between(agent.x, agent.y, nearestEnemy.x, nearestEnemy.y) / Math.PI;
    }

    // PHDM cognitive state input (current lobe weight normalized)
    const phdmWeight = agent.brain ? (agent.brain.phdm.currentLobe.weight / 10.0) : 0.5;

    // Gravitational context (how dilated are nearby enemies?)
    let avgEnemyDilation = 1.0;
    const nearbyEnemies = enemies.filter(e => e.hp > 0 && e.dilationFactor !== undefined);
    if (nearbyEnemies.length > 0) {
        avgEnemyDilation = nearbyEnemies.reduce((sum, e) => sum + e.dilationFactor, 0) / nearbyEnemies.length;
    }

    return [
        nearestEnemyDist / arenaRadius,
        enemyAngle,
        agent.hp / agent.maxHp,
        nearestAllyDist / arenaRadius,
        formationBonus,
        enemyCount,
        allyCount,
        Math.random() * 0.1,
        phdmWeight,          // PHDM cognitive state
        avgEnemyDilation     // Gravity awareness
    ];
}

function findNearestEnemy(agent, targets) {
    let nearest = null;
    let nearestDist = 9999;
    targets.forEach(t => {
        if (t.hp <= 0) return;
        const d = Phaser.Math.Distance.Between(agent.x, agent.y, t.x, t.y);
        if (d < nearestDist) {
            nearestDist = d;
            nearest = t;
        }
    });
    return nearest;
}

function attack(scene, attacker, target) {
    // Visual projectile
    const proj = scene.add.circle(attacker.x, attacker.y, 4, attacker.isEnemy ? 0xff4444 : 0x00ffcc);
    proj.life = 200;
    projectiles.push(proj);

    // Animate to target
    scene.tweens.add({
        targets: proj,
        x: target.x,
        y: target.y,
        duration: 150,
        onComplete: () => {
            target.hp -= attacker.damage;
            if (!attacker.isEnemy) {
                attacker.score += 5; // Damage reward
                if (target.hp <= 0) {
                    attacker.score += 50; // Kill reward
                    addLog(attacker.tongue.id + ' eliminated enemy!', 'good');
                }
            } else if (target.hp <= 0) {
                addLog(target.tongue.id + ' was eliminated!', 'bad');
            }
        }
    });
}

function updateAgentVisuals(agent) {
    agent.hpBar.x = agent.x;
    agent.hpBar.y = agent.y - 20;
    agent.hpBarBg.x = agent.x;
    agent.hpBarBg.y = agent.y - 20;
    agent.label.x = agent.x;
    agent.label.y = agent.y + 20;

    const hpPercent = Math.max(0, agent.hp / agent.maxHp);
    agent.hpBar.width = 24 * hpPercent;
    agent.hpBar.fillColor = hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000;

    if (agent.hp <= 0) {
        agent.alpha = 0.3;
        agent.hpBar.visible = false;
    }
}

function endBattle(scene, won) {
    battleActive = false;

    // Calculate final scores
    const scores = allies.map(a => a.score + (a.hp > 0 ? 20 : 0));
    trainer.recordBattle(won, scores);

    addLog(won ? 'VICTORY! Evolving...' : 'Defeat. Evolving...', won ? 'good' : 'bad');

    // Evolve after every battle
    trainer.evolve();

    // Start next battle after delay
    scene.time.delayedCall(fastMode ? 500 : 1500, () => {
        startBattle(scene);
    });
}

function updateUI() {
    document.getElementById('gen').textContent = trainer.generation;
    document.getElementById('best-fitness').textContent = trainer.bestFitness.toFixed(1);
    document.getElementById('avg-fitness').textContent = (trainer.population.reduce((s, p) => s + p.fitness, 0) / 6).toFixed(1);
    document.getElementById('battles').textContent = trainer.battles;
    document.getElementById('winrate').textContent = trainer.battles > 0 ? ((trainer.wins / trainer.battles) * 100).toFixed(1) + '%' : '0%';
    document.getElementById('mutation').textContent = (trainer.mutationRate * 100).toFixed(1) + '%';

    // Update tongue stats
    allies.forEach((a, i) => {
        const id = SACRED_TONGUES[i].id.toLowerCase();
        const elem = document.getElementById(id + '-stat');
        if (elem) {
            elem.textContent = a.hp > 0 ? Math.round((a.hp / a.maxHp) * 100) + '%' : 'DEAD';
            elem.style.color = a.hp > 0 ? '#00ff88' : '#ff4444';
        }
    });

    // Update PHDM panel
    if (allies.length > 0 && allies[0].brain) {
        const leadBrain = allies[0].brain;
        document.getElementById('active-lobe').textContent = leadBrain.phdm.currentLobe.id;
        document.getElementById('flux-value').textContent = leadBrain.phdm.flux.toFixed(3);
        document.getElementById('breath-state').textContent = leadBrain.phdm.breathState;
        document.getElementById('hamilton-valid').textContent = leadBrain.phdm.pathValid ? '✓ VALID' : '✗ PHASON';
        document.getElementById('hamilton-valid').style.color = leadBrain.phdm.pathValid ? '#00ff88' : '#ff4444';
    }

    // Draw neural weights visualization
    drawBrainViz();

    // Draw skull visualization
    drawSkullViz();
}

function drawSkullViz() {
    const canvas = document.getElementById('skull-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the 16 polyhedra as nodes
    const polyList = Object.values(POLYHEDRA);
    const nodeRadius = 4;
    const padding = 10;
    const usableWidth = canvas.width - padding * 2;
    const spacing = usableWidth / (polyList.length + 1);

    // Ring colors
    const ringColors = {
        'CORE': '#00ff88',
        'INNER': '#ffcc00',
        'MIDDLE': '#ff6600',
        'EDGE': '#ff0066'
    };

    // Draw nodes
    polyList.forEach((poly, i) => {
        const x = padding + spacing * (i + 1);
        const y = canvas.height / 2;

        // Highlight current lobe
        const isActive = allies.length > 0 && allies[0].brain &&
                         allies[0].brain.phdm.currentLobe.id === poly.id;

        ctx.beginPath();
        ctx.arc(x, y, isActive ? nodeRadius * 2 : nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = isActive ? '#ffffff' : ringColors[poly.ring];
        ctx.fill();

        // Spiky indicator for Kepler-Poinsot
        if (poly.spiky) {
            ctx.strokeStyle = '#ff0066';
            ctx.lineWidth = 1;
            for (let j = 0; j < 4; j++) {
                const angle = (j / 4) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
                ctx.stroke();
            }
        }
    });

    // Draw Hamiltonian edges (simplified visualization)
    ctx.strokeStyle = 'rgba(255,0,255,0.2)';
    ctx.lineWidth = 1;
    polyList.forEach((poly, i) => {
        const x1 = padding + spacing * (i + 1);
        const edges = HAMILTONIAN_EDGES[poly.id] || [];
        edges.forEach(targetId => {
            const targetIdx = polyList.findIndex(p => p.id === targetId);
            if (targetIdx > i) {
                const x2 = padding + spacing * (targetIdx + 1);
                ctx.beginPath();
                ctx.moveTo(x1, canvas.height / 2);
                ctx.lineTo(x2, canvas.height / 2);
                ctx.stroke();
            }
        });
    });
}

function drawBrainViz() {
    const canvas = document.getElementById('brain-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!trainer.bestBrain) return;

    const weights = trainer.bestBrain.weightsIH.flat();
    const barWidth = canvas.width / weights.length;

    weights.forEach((w, i) => {
        const h = Math.abs(w) * 30;
        const color = w > 0 ? '#00ff88' : '#ff4444';
        ctx.fillStyle = color;
        ctx.fillRect(i * barWidth, canvas.height / 2 - h / 2, barWidth - 1, h);
    });
}

function addLog(msg, type = 'info') {
    const log = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = 'log-entry log-' + type;
    entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
    log.insertBefore(entry, log.firstChild);
    if (log.children.length > 20) {
        log.removeChild(log.lastChild);
    }
}

function setupControls(scene) {
    document.getElementById('btn-start').onclick = () => {
        if (!battleActive) startBattle(scene);
    };

    document.getElementById('btn-pause').onclick = () => {
        paused = !paused;
        document.getElementById('btn-pause').textContent = paused ? 'RESUME' : 'PAUSE';
        addLog(paused ? 'Training paused' : 'Training resumed', 'info');
    };

    document.getElementById('btn-fast').onclick = () => {
        fastMode = !fastMode;
        document.getElementById('btn-fast').classList.toggle('active', fastMode);
        addLog('Fast mode: ' + (fastMode ? 'ON' : 'OFF'), 'info');
    };

    document.getElementById('btn-hex').onclick = () => { currentFormation = 'hex'; addLog('Formation: Hexagonal', 'info'); };
    document.getElementById('btn-tetra').onclick = () => { currentFormation = 'tetra'; addLog('Formation: Tetrahedral', 'info'); };
    document.getElementById('btn-scatter').onclick = () => { currentFormation = 'scatter'; addLog('Formation: Scatter', 'info'); };
}

// Initialize game
game = new Phaser.Game(config);
    </script>
</body>
</html>
