from __future__ import annotations

from typing import List

from .models import PrismFunction, PrismModule


def _py_signature(fn: PrismFunction) -> str:
    args = ", ".join(fn.args)
    suffix = f" -> {fn.returns}" if fn.returns else ""
    return f"def {fn.name}({args}){suffix}:"


def emit_python(module: PrismModule) -> str:
    out: List[str] = ['"""Generated by Code Prism."""', ""]
    for fn in module.functions:
        out.append(_py_signature(fn))
        if fn.docstring:
            out.append(f'    """{fn.docstring}"""')
        for line in fn.body:
            out.append(f"    {line}")
        out.append("")
    return "\n".join(out).rstrip() + "\n"


def _ts_signature(fn: PrismFunction) -> str:
    args = ", ".join(f"{arg}: any" for arg in fn.args)
    ret = fn.returns or "any"
    return f"export function {fn.name}({args}): {ret} {{"


def emit_typescript(module: PrismModule) -> str:
    out: List[str] = ["// Generated by Code Prism.", ""]
    for fn in module.functions:
        out.append(_ts_signature(fn))
        if fn.docstring:
            out.append(f"  // {fn.docstring}")
        if fn.body:
            out.append("  // Translated body:")
            for line in fn.body:
                ts_line = line if line.endswith(";") else f"{line};"
                out.append(f"  {ts_line}")
        else:
            out.append("  // TODO: implement")
        out.append("}")
        out.append("")
    return "\n".join(out).rstrip() + "\n"


def _go_signature(fn: PrismFunction) -> str:
    args = ", ".join(f"{arg} interface{{}}" for arg in fn.args)
    return f"func {fn.name.title()}({args}) interface{{}} {{"


def emit_go(module: PrismModule) -> str:
    out: List[str] = [
        "// Generated by Code Prism.",
        "package prism",
        "",
    ]
    for fn in module.functions:
        out.append(_go_signature(fn))
        if fn.docstring:
            out.append(f"    // {fn.docstring}")
        out.append("    // TODO: translate implementation")
        out.append("    return nil")
        out.append("}")
        out.append("")
    return "\n".join(out).rstrip() + "\n"


def emit_from_ir(module: PrismModule, target_language: str) -> str:
    lang = target_language.lower()
    if lang == "python":
        return emit_python(module)
    if lang in {"typescript", "ts"}:
        return emit_typescript(module)
    if lang == "go":
        return emit_go(module)
    raise ValueError(f"Unsupported target language: {target_language}")

